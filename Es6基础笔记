   摘自 阮一峰
   Es6一共有六种声明变量的方法： let const  import class（不属于顶层对象的属性 let a=1;window.a  //undefine）     var function（属于顶层对象的属性，var a= 1; window.a //1）
一.let和const命令
   let用来声明变量，但只在代码块内有效，即{有效范围}   如{let a= 10; var b=1;}   a //报错(a is not defined) b//1
 用法  
   var a = [];
for (let i = 0; i < 10; i++) { //----》修改成var  结果为 10，var声明的范围全局有效，所有成员数组的i指向的都是全局的i，每次循环i变化，输出最后一轮i值
  a[i] = function () {
    console.log(i);
  };
}
a[6]();//6  

用法：for的let使用特别之处
for (let i = 0; i < 3; i++) {//这个let是父作用域 ，这里改为var 结果也是输出3次 abc
  let i = 'abc';      //这个是子作用域，不能改为 var，因为var会指向全局，导致报错
  console.log(i);   //输出3次 abc
}

重要---- 用法二:  let不存在变量提升（防止在变量声明前就使用这个变量），var 存在变量提升
 console.log(foo); //输出undefined，说明变量提升了
 var foo =2 ;   

console.log(bar);  //报错ReferenceError
let bar = 2;

用法三：let导致暂时性死区 （在let声明之前使用 都会造成死区）
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束---》因为这里，上面死区了，导致程序报错
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
重要---用法四：不允许重复声明
  // 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}

function func(arg) { //注意不能形参不能和实参同名
  let arg; // 报错
}
注意下面这个不报错，那是子作用域
function func(arg) {
  {
    let arg; // 不报错， 
  }
}
重要---用法五：任意嵌套，外层作用域无法读取内层作用域
{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错
}}}};

--------const----- 并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
  对象：   
     const foo = {};
      // 为 foo 添加一个属性，可以成功
      foo.prop = 123;
      foo.prop // 123
      // 将 foo 指向另一个对象，就会报错
      foo = {}; // TypeError: "foo" is read-only
  数组：
    const a = [];
   a.push('Hello'); // 可执行
   a.length = 0;    // 可执行
   a = ['Dave'];    // 报错

二、变量的结构赋值
ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（本质是模式匹配）
 let [a, b, c] = [1, 2, 3];  等价 let a = 1;let b = 2;let c = 3;
 let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1 bar // 2  baz // 3
 let [foo] = []; let [bar, foo] = [1];两种情况都属于解构不成功，foo的值都会等于undefined。
 let [x, y] = [1, 2, 3];x // 1 y // 2 不完全解构，两边不匹配，也能成功
 let [x, y, z] = new Set(['a', 'b', 'c']);  Set结构，也可以使用数组的解构赋值。
 let [foo = true] = [];foo // true let [x, y = 'b'] = ['a']; // x='a', y='b' let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'赋默认值
 let [x = 1] = [undefined]; let [x = 1] = [null];如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。

 let { foo, bar } = { foo: "aaa", bar: "bbb" }; foo // "aaa"  bar // "bbb"
 let { foo: baz } = { foo: 'aaa', bar: 'bbb' }; baz // "aaa"
 let obj = { first: 'hello', last: 'world' };let { first: f, last: l } = obj;f // 'hello' l // 'world' 变量名与属性名不一致
三、字符串的扩展
四、正则的扩展
五、数值的扩展
六、函数的扩展
七、数组的扩展
八、对象的扩展
九、Symbol---增加的数据类型
十、Set和Map数据结构
十一、Proxy
十二、Reflect
十三、Promise对象
十四、Iterator和for...of循环
十五、Generator函数的语法
十六、Generator函数的异步运用
十七、async函数
十八、Class的基本用法
十九、Class的继承
二十、Decorator
二十一、Module的语法
二十二、Module的加载实现
二十三、编程风格
二十四、读懂规格
二十五、ArrayBuffer

