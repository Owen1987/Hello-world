   摘自 阮一峰
一.let和const命令
   let用来声明变量，但只在代码块内有效，即{有效范围}   如{let a= 10; var b=1;}   a //报错(a is not defined) b//1
 用法  
   var a = [];
for (let i = 0; i < 10; i++) { //----》修改成var  结果为 10，var声明的范围全局有效，所有成员数组的i指向的都是全局的i，每次循环i变化，输出最后一轮i值
  a[i] = function () {
    console.log(i);
  };
}
a[6]();//6  

用法：for的let使用特别之处
for (let i = 0; i < 3; i++) {//这个let是父作用域 ，这里改为var 结果也是输出3次 abc
  let i = 'abc';      //这个是子作用域，不能改为 var，因为var会指向全局，导致报错
  console.log(i);   //输出3次 abc
}

重要---- 用法二:  let不存在变量提升（防止在变量声明前就使用这个变量），var 存在变量提升
 console.log(foo); //输出undefined，说明变量提升了
 var foo =2 ;   

console.log(bar);  //报错ReferenceError
let bar = 2;

用法三：let导致暂时性死区 （在let声明之前使用 都会造成死区）
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束---》因为这里，上面死区了，导致程序报错
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
重要---用法四：不允许重复声明
  // 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}

function func(arg) { //注意不能形参不能和实参同名
  let arg; // 报错
}
注意下面这个不报错，那是子作用域
function func(arg) {
  {
    let arg; // 不报错， 
  }
}
重要---用法五：任意嵌套，外层作用域无法读取内层作用域
{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错
}}}};




二、变量的结构赋值
三、字符串的扩展
四、正则的扩展
五、数值的扩展
六、函数的扩展
七、数组的扩展
八、对象的扩展
九、Symbol---增加的数据类型
十、Set和Map数据结构
十一、Proxy
十二、Reflect
十三、Promise对象
十四、Iterator和for...of循环
十五、Generator函数的语法
十六、Generator函数的异步运用
十七、async函数
十八、Class的基本用法
十九、Class的继承
二十、Decorator
二十一、Module的语法
二十二、Module的加载实现
二十三、编程风格
二十四、读懂规格
二十五、ArrayBuffer

