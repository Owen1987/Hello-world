   摘自 阮一峰
   Es6一共有六种声明变量的方法： let const  import class（不属于顶层对象的属性 let a=1;window.a  //undefine）     var function（属于顶层对象的属性，var a= 1; window.a //1）
一.let和const命令
   let用来声明变量，但只在代码块内有效，即{有效范围}   如{let a= 10; var b=1;}   a //报错(a is not defined) b//1
 用法  
   var a = [];
for (let i = 0; i < 10; i++) { //----》修改成var  结果为 10，var声明的范围全局有效，所有成员数组的i指向的都是全局的i，每次循环i变化，输出最后一轮i值
  a[i] = function () {
    console.log(i);
  };
}
a[6]();//6  

用法：for的let使用特别之处
for (let i = 0; i < 3; i++) {//这个let是父作用域 ，这里改为var 结果也是输出3次 abc
  let i = 'abc';      //这个是子作用域，不能改为 var，因为var会指向全局，导致报错
  console.log(i);   //输出3次 abc
}

重要---- 用法二:  let不存在变量提升（防止在变量声明前就使用这个变量），var 存在变量提升
 console.log(foo); //输出undefined，说明变量提升了
 var foo =2 ;   

console.log(bar);  //报错ReferenceError
let bar = 2;

用法三：let导致暂时性死区 （在let声明之前使用 都会造成死区）
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束---》因为这里，上面死区了，导致程序报错
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
重要---用法四：不允许重复声明
  // 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}

function func(arg) { //注意不能形参不能和实参同名
  let arg; // 报错
}
注意下面这个不报错，那是子作用域
function func(arg) {
  {
    let arg; // 不报错， 
  }
}
重要---用法五：任意嵌套，外层作用域无法读取内层作用域
{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错
}}}};

--------const----- 并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
  对象：   
     const foo = {};
      // 为 foo 添加一个属性，可以成功
      foo.prop = 123;
      foo.prop // 123
      // 将 foo 指向另一个对象，就会报错
      foo = {}; // TypeError: "foo" is read-only
  数组：
    const a = [];
   a.push('Hello'); // 可执行
   a.length = 0;    // 可执行
   a = ['Dave'];    // 报错

二、变量的结构赋值
ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（本质是模式匹配）
     数组
 let [a, b, c] = [1, 2, 3];  等价 let a = 1;let b = 2;let c = 3;
 let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1 bar // 2  baz // 3
 let [foo] = []; let [bar, foo] = [1];两种情况都属于解构不成功，foo的值都会等于undefined。
 let [x, y] = [1, 2, 3];x // 1 y // 2 不完全解构，两边不匹配，也能成功
 let [x, y, z] = new Set(['a', 'b', 'c']);  Set结构，也可以使用数组的解构赋值。
 let [foo = true] = [];foo // true let [x, y = 'b'] = ['a']; // x='a', y='b' let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'赋默认值
 let [x = 1] = [undefined]; let [x = 1] = [null];如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。
      对象
 let { foo, bar } = { foo: "aaa", bar: "bbb" }; foo // "aaa"  bar // "bbb"
 let { foo: baz } = { foo: 'aaa', bar: 'bbb' }; baz // "aaa"
 let obj = { first: 'hello', last: 'world' };let { first: f, last: l } = obj;f // 'hello' l // 'world' 变量名与属性名不一致
     字符串的解构赋值
     字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
  const [a, b, c, d, e] = 'hello'; a // "h" b // "e" c // "l" d // "l" e // "o"
     数值和布尔值的解构赋值
解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
let {toString: s} = 123; s === Number.prototype.toString // true
let {toString: s} = true; s === Boolean.prototype.toString // true

  函数参数的解构赋值
函数的参数也可以使用解构赋值。

function add([x, y]){
  return x + y;
}

add([1, 2]); // 3
上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。

下面是另一个例子。

[[1, 2], [3, 4]].map(([a, b]) => a + b);
// [ 3, 7 ]
函数参数的解构也可以使用默认值。

function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。

注意，下面的写法会得到不一样的结果。

function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]
上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。

undefined就会触发函数参数的默认值。

[1, undefined, 3].map((x = 'yes') => x);
// [ 1, 'yes', 3 ]

重点：解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。
let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
注意：解构赋值忌讳 圆括号问题
// 全部报错
let [(a)] = [1];
let {x: (c)} = {};
let ({x: c}) = {};
let {(x: c)} = {};
let {(x): c} = {};
let { o: ({ p: p }) } = { o: { p: 2 } };

可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。
[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确

用途：
（1）交换变量的值
let x = 1;let y = 2;[x, y] = [y, x];
（2）从函数返回多个值
// 返回一个数组
function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();
// 返回一个对象
function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();
（3）函数参数的定义
解构赋值可以方便地将一组参数与变量名对应起来。
// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});

（4）提取 JSON 数据
解构赋值对提取 JSON 对象中的数据，尤其有用。
let jsonData = {
  id: 42,
  status: "OK",
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;
console.log(id, status, number);
// 42, "OK", [867, 5309]
上面代码可以快速提取 JSON 数据的值。

（5）函数参数的默认值
jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
}) {
  // ... do stuff
};
指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。

（6）遍历 Map 结构
任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。
const map = new Map();
map.set('first', 'hello');
map.set('second', 'world');
for (let [key, value] of map) {
  console.log(key + " is " + value);
}
// first is hello
// second is world
如果只想获取键名，或者只想获取键值，可以写成下面这样。
// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...
}
（7）输入模块的指定方法
加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。
const { SourceMapConsumer, SourceNode } = require("source-map");

三、字符串的扩展
        如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。

      $('#list').html(`
      <ul>
        <li>first</li>
        <li>second</li>
      </ul>
      `);
      上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<ul>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。

      $('#list').html(`
      <ul>
        <li>first</li>
        <li>second</li>
      </ul>
      `.trim());
      模板字符串中嵌入变量，需要将变量名写在${}之中。

      function authorize(user, action) {
        if (!user.hasPrivilege(action)) {
          throw new Error(
            // 传统写法为
            // 'User '
            // + user.name
            // + ' is not authorized to do '
            // + action
            // + '.'
            `User ${user.name} is not authorized to do ${action}.`);
        }
      }
      大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。

      let x = 1;
      let y = 2;

      `${x} + ${y} = ${x + y}`
      // "1 + 2 = 3"

      `${x} + ${y * 2} = ${x + y * 2}`
      // "1 + 4 = 5"

      let obj = {x: 1, y: 2};
      `${obj.x + obj.y}`
      // "3"
      模板字符串之中还能调用函数。

      function fn() {
        return "Hello World";
      }

      `foo ${fn()} bar`
      // foo Hello World bar
      如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。

      如果模板字符串中的变量没有声明，将报错。

      // 变量place没有声明
      let msg = `Hello, ${place}`;
      // 报错
      由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。

      `Hello ${'World'}`
      // "Hello World"
      模板字符串甚至还能嵌套。

      const tmpl = addrs => `
        <table>
        ${addrs.map(addr => `
          <tr><td>${addr.first}</td></tr>
          <tr><td>${addr.last}</td></tr>
        `).join('')}
        </table>
      `;
      上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。

      const data = [
          { first: '<Jane>', last: 'Bond' },
          { first: 'Lars', last: '<Croft>' },
      ];

      console.log(tmpl(data));
      // <table>
      //
      //   <tr><td><Jane></td></tr>
      //   <tr><td>Bond</td></tr>
      //
      //   <tr><td>Lars</td></tr>
      //   <tr><td><Croft></td></tr>
      //
      // </table>
      如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。

      // 写法一
      let str = 'return ' + '`Hello ${name}!`';
      let func = new Function('name', str);
      func('Jack') // "Hello Jack!"

      // 写法二
      let str = '(name) => `Hello ${name}!`';
      let func = eval.call(null, str);
      func('Jack') // "Hello Jack!"
四、正则的扩展
   在 ES5 中，RegExp构造函数的参数有两种情况。

   第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。

   var regex = new RegExp('xyz', 'i');
   // 等价于
   var regex = /xyz/i;
   第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。

   var regex = new RegExp(/xyz/i);
   // 等价于
   var regex = /xyz/i;
   但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。

   var regex = new RegExp(/xyz/, 'i');
   // Uncaught TypeError: Cannot supply flags when constructing one RegExp from another
   ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。

   new RegExp(/abc/ig, 'i').flags
   // "i"
五、数值的扩展（省略）
六、函数的扩展
  ES5 :
  function log(x, y) {
  y = y || 'World';
  console.log(x, y);
 }
 log('Hello') // Hello World
 log('Hello', 'China') // Hello China
 log('Hello', '') // Hello World
 
 ES6:
    function log(x, y = 'World') {
     console.log(x, y);
   }
   log('Hello') // Hello World
   log('Hello', 'China') // Hello China
   log('Hello', '') // Hello
   
   与解构赋值默认值结合使用
参数默认值可以与解构赋值的默认值，结合起来使用。
function foo({x, y = 5}) {
  console.log(x, y);
}
foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property 'x' of undefined(报错)

function foo({x, y = 5} = {}) {//如果没有提供参数，函数foo的参数默认为一个空对象。
  console.log(x, y);
}
foo() // undefined 5
看下两种写法的区别：
// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x 和 y 都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x 和 y 都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]

箭头函数：
var f = v => v; 等价于 var f = function(v) {  return v; };
var sum = (num1, num2) => num1 + num2;// 等同于var sum = function(num1, num2) { return num1 + num2;};

function Timer() {
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数:绑定定义时所在的作用域
  setInterval(() => this.s1++, 1000);
  // 普通函数：指向运行时所在的作用，
  setInterval(function () {
    this.s2++;   //运行时指向window
  }, 1000);
}

var timer = new Timer();

setTimeout(() => console.log('s1: ', timer.s1), 3100);
setTimeout(() => console.log('s2: ', timer.s2), 3100);
// s1: 3
// s2: 0


嵌套的箭头函数
箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。

function insert(value) {
  return {into: function (array) {
    return {after: function (afterValue) {
      array.splice(array.indexOf(afterValue) + 1, 0, value);
      return array;
    }};
  }};
}

insert(2).into([1, 3]).after(1); //[1, 2, 3]
上面这个函数，可以使用箭头函数改写。

let insert = (value) => ({into: (array) => ({after: (afterValue) => {
  array.splice(array.indexOf(afterValue) + 1, 0, value);
  return array;
}})});

insert(2).into([1, 3]).after(1); //[1, 2, 3]
七、数组的扩展
    数组的扩展运算符是三个点（...），将一个数组转为用逗号分隔的参数序列。
   console.log(...[1, 2, 3])// 1 2 3
   console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5  
   [...document.querySelectorAll('div')]// [<div>, <div>, <div>] 
   
  该运算符主要用于函数调用。该运算符将一个数组，变为参数序列。

function push(array, ...items) {
  array.push(...items);
}
function add(x, y) {
  return x + y;
}
const numbers = [4, 38];
add(...numbers) // 42

  ...替代数组的apply方法：
  // ES5 的写法
function f(x, y, z) {
  // ...
}
var args = [0, 1, 2];
f.apply(null, args);

// ES6的写法
function f(x, y, z) {
  // ...
}
let args = [0, 1, 2];
f(...args);
  例子2 ...替代apply
// ES5 的写法
Math.max.apply(null, [14, 3, 77])

// ES6 的写法
Math.max(...[14, 3, 77])

// 等同于
Math.max(14, 3, 77);
扩展符的运用： 
  复制数组 
  const a1 = [1, 2];
  const a2 = a1; 
  a2[0] = 2;//直接赋值改变a2直接影响a1
  a1 // [2, 2]
  改进方法如下：
  es5的“”
  const a1 = [1, 2];
const a2 = a1.concat();
a2[0] = 2;//通过拼接一个空数组形成一个新的数组改变了地址指针，完成复制
a1 // [1, 2]
  ES6的：
  const a1 = [1, 2];
   // 写法一
   const a2 = [...a1];
   // 写法二
   const [...a2] = a1;
 二. 合并数组

扩展运算符提供了数组合并的新写法。

// ES5
[1, 2].concat(more)
// ES6
[1, 2, ...more]

var arr1 = ['a', 'b'];
var arr2 = ['c'];
var arr3 = ['d', 'e'];

// ES5的合并数组
arr1.concat(arr2, arr3);
// [ 'a', 'b', 'c', 'd', 'e' ]

// ES6的合并数组
[...arr1, ...arr2, ...arr3] 

八、对象的扩展
   对象的简写：属性简写/方法简写
  一. 属性简写：简洁表示法、属性名表达式 （属性名表达式与简洁表示法，不能同时使用，会报错。）
   const foo = 'bar';
   const baz = {foo};//简写
  baz // {foo: "bar"}
  // 等同于
  const baz = {foo: foo};
  
  function f(x, y) {
    return {x, y};  //简写
  }
// 等同于
function f(x, y) {
  return {x: x, y: y};
}
f(1, 2) // Object {x: 1, y: 2}
  
 方法简写：
 const o = {
  method() {  //简写
    return "Hello!";
  }
};
// 等同于
const o = {
  method: function() {
    return "Hello!";
  }
};
 
 CommonJS 模块输出一组变量，就非常合适使用简洁写法。
 let ms = {};
function getItem (key) {
  return key in ms ? ms[key] : null;
}
function setItem (key, value) {
  ms[key] = value;
}
function clear () {
  ms = {};
}
module.exports = { getItem, setItem, clear };//简写
// 等同于
module.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
};
 属性简写：属性名表达式
  js:
   // 方法一（标识符）
   obj.foo = true;

   // 方法二（表达式）
   obj['a' + 'bc'] = 123;
 其中es5 字面量定义对象只可用标识符的方式定义属性
    var obj = {
     foo: true,
     abc: 123
   };
 但ES6允许在字面量定义对象的时候用方法二（表达式）定义属性
 let propKey = 'foo';
  let obj = {
  [propKey]: true, //表达式放在[]内
  ['a' + 'bc']: 123
  };
   
   对象的合并：Object.assign();
   
   const target = { a: 1 };const source1 = { b: 2 };const source2 = { c: 3 };  
   Object.assign(target, source1, source2);
   target // {a:1, b:2, c:3}
   由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。
   Object.assign(undefined) // 报错
   Object.assign(null) // 报错
 
九、Symbol---增加的数据类型
   ES5 的对象属性名都是字符串，这容易造成属性名的冲突。ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值
   let s = Symbol();typeof s // "symbol"
   
   let s1 = Symbol('foo');
   let s2 = Symbol('bar');
   s1 // Symbol(foo)
   s2 // Symbol(bar)
   s1.toString() // "Symbol(foo)"
   s2.toString() // "Symbol(bar)"
   由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性
   这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。
   let mySymbol = Symbol();
   // 第一种写法
   let a = {};
   a[mySymbol] = 'Hello!';
   // 第二种写法
   let a = {
     [mySymbol]: 'Hello!'
   };
   // 第三种写法
   let a = {};
   Object.defineProperty(a, mySymbol, { value: 'Hello!' });
   // 以上写法都得到同样结果
   a[mySymbol] // "Hello!"
   
   
十、Set和Map数据结构
  ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值,Set是一个构造函数
  const s = new Set();
   [2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
   for (let i of s) {
    console.log(i);
   }
   // 2 3 5 4
   
   Set函数可以接受一个数组
   // 例一
const set = new Set([1, 2, 3, 4, 4]);
[...set]
// [1, 2, 3, 4]

// 例二
const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 5

// 例三
function divs () {
  return [...document.querySelectorAll('div')];
}

const set = new Set(divs());
set.size // 56

// 类似于
divs().forEach(div => set.add(div));
set.size // 56

// 去除数组的重复成员（注意有这个[]才是数组）
[...new Set(array)]



十一、Proxy
十二、Reflect
十三、Promise对象
十四、Iterator和for...of循环
十五、Generator函数的语法
十六、Generator函数的异步运用
十七、async函数
十八、Class的基本用法
十九、Class的继承
二十、Decorator
二十一、Module的语法
二十二、Module的加载实现
二十三、编程风格
二十四、读懂规格
二十五、ArrayBuffer

